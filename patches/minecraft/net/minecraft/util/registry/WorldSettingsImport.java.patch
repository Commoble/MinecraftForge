--- a/net/minecraft/util/registry/WorldSettingsImport.java
+++ b/net/minecraft/util/registry/WorldSettingsImport.java
@@ -45,12 +_,18 @@
    public final WorldSettingsImport<JsonElement> field_244333_f;
 
    public static <T> WorldSettingsImport<T> func_244335_a(DynamicOps<T> p_244335_0_, IResourceManager p_244335_1_, DynamicRegistries.Impl p_244335_2_) {
-      return func_244336_a(p_244335_0_, WorldSettingsImport.IResourceAccess.func_244345_a(p_244335_1_), p_244335_2_);
+      return create(p_244335_0_, WorldSettingsImport.IResourceAccess.func_244345_a(p_244335_1_), p_244335_2_, true); // this method is only called by things that are importing datapacks (not RegistryAccess.builtin()), add extra arg passing this information
    }
 
    public static <T> WorldSettingsImport<T> func_244336_a(DynamicOps<T> p_244336_0_, WorldSettingsImport.IResourceAccess p_244336_1_, DynamicRegistries.Impl p_244336_2_) {
+      return create(p_244336_0_, p_244336_1_, p_244336_2_, false); // with these patches, this method is now only called by RegistryAccess.builtin() (not importing datapacks), add extra arg passing this information
+   }
+   public final WorldSettingsImport<net.minecraft.nbt.INBT> nbtOps; // in order to prevent redundant imports, we need to be able to provide the NBT variant of this if requested
+   public static <T> WorldSettingsImport<T> create(DynamicOps<T> p_244336_0_, WorldSettingsImport.IResourceAccess p_244336_1_, DynamicRegistries.Impl p_244336_2_, boolean importingDataPacks) { // add extra argument to this constructor so we can tell whether it's being called to import datapacks or to create the builtin registries
+      if (importingDataPacks && p_244336_2_.getDatapackImports() != null) return net.minecraftforge.common.ForgeHooks.getCachedRegistryOps(p_244336_0_, p_244336_2_.getDatapackImports()); // if this isn't the first time we're importing datapacks into these registries, return a previously-created RegistryReadOps and don't fire the registries loaded event
       WorldSettingsImport<T> worldsettingsimport = new WorldSettingsImport<>(p_244336_0_, p_244336_1_, p_244336_2_, Maps.newIdentityHashMap());
       DynamicRegistries.func_243608_a(p_244336_2_, worldsettingsimport);
+      if (importingDataPacks) { net.minecraftforge.common.ForgeHooks.onDynamicRegistriesLoaded(worldsettingsimport, p_244336_2_);} // if this is the first time we're importing datapacks into these registries, the event should be fired (but not for builtin data)
       return worldsettingsimport;
    }
 
@@ -60,7 +_,16 @@
       this.field_240872_d_ = p_i242092_3_;
       this.field_240873_e_ = p_i242092_4_;
       this.field_244333_f = p_i242092_1_ == JsonOps.INSTANCE ? (WorldSettingsImport<JsonElement>)this : new WorldSettingsImport<>(JsonOps.INSTANCE, p_i242092_2_, p_i242092_3_, p_i242092_4_);
+      this.nbtOps = p_i242092_1_ == net.minecraft.nbt.NBTDynamicOps.field_210820_a ? (WorldSettingsImport<net.minecraft.nbt.INBT>)this : new WorldSettingsImport<net.minecraft.nbt.INBT>(p_i242092_2_, p_i242092_3_, p_i242092_4_, this.field_244333_f); // all vanilla RegistryReadOps either are or have a jsonops delegate, we also need to have an nbtops delegate to prevent redundant imports
    }
+   private WorldSettingsImport(WorldSettingsImport.IResourceAccess resources, DynamicRegistries.Impl registryHolder, IdentityHashMap<RegistryKey<? extends Registry<?>>, WorldSettingsImport.ResultMap<?>> readCache, WorldSettingsImport<JsonElement> jsonOps) {
+      super((DynamicOps<T>) net.minecraft.nbt.NBTDynamicOps.field_210820_a);
+      this.field_244332_c = resources;
+      this.field_240872_d_ = registryHolder;
+      this.field_240873_e_ = readCache;
+      this.field_244333_f = jsonOps;
+      this.nbtOps = (WorldSettingsImport<net.minecraft.nbt.INBT>)this;
+   } // extra constructor is needed to have both a json and nbt ops delegate, otherwise this class recursively constructs itself in the jsonOps assignment in the other constructor forever
 
    protected <E> DataResult<Pair<Supplier<E>, T>> func_241802_a_(T p_241802_1_, RegistryKey<? extends Registry<E>> p_241802_2_, Codec<E> p_241802_3_, boolean p_241802_4_) {
       Optional<MutableRegistry<E>> optional = this.field_240872_d_.func_230521_a_(p_241802_2_);
@@ -190,6 +_,7 @@
                ) {
                   JsonParser jsonparser = new JsonParser();
                   JsonElement jsonelement = jsonparser.parse(reader);
+                  if (jsonelement!= null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_241879_3_.func_240901_a_().toString());
                   return p_241879_4_.parse(p_241879_1_, jsonelement).map((p_244347_0_) -> {
                      return Pair.of(p_244347_0_, OptionalInt.empty());
                   });
@@ -231,6 +_,7 @@
 
          public <E> DataResult<Pair<E, OptionalInt>> func_241879_a(DynamicOps<JsonElement> p_241879_1_, RegistryKey<? extends Registry<E>> p_241879_2_, RegistryKey<E> p_241879_3_, Decoder<E> p_241879_4_) {
             JsonElement jsonelement = this.field_244349_a.get(p_241879_3_);
+            if (jsonelement!= null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_241879_3_.func_240901_a_().toString());
             return jsonelement == null ? DataResult.error("Unknown element: " + p_241879_3_) : p_241879_4_.parse(p_241879_1_, jsonelement).setLifecycle(this.field_244351_c.get(p_241879_3_)).map((p_244353_2_) -> {
                return Pair.of(p_244353_2_, OptionalInt.of(this.field_244350_b.getInt(p_241879_3_)));
             });
