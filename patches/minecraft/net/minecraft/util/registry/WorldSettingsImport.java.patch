--- a/net/minecraft/util/registry/WorldSettingsImport.java
+++ b/net/minecraft/util/registry/WorldSettingsImport.java
@@ -45,12 +_,18 @@
    private final WorldSettingsImport<JsonElement> field_244333_f;
 
    public static <T> WorldSettingsImport<T> func_244335_a(DynamicOps<T> p_244335_0_, IResourceManager p_244335_1_, DynamicRegistries.Impl p_244335_2_) {
-      return func_244336_a(p_244335_0_, WorldSettingsImport.IResourceAccess.func_244345_a(p_244335_1_), p_244335_2_);
+      return create(p_244335_0_, WorldSettingsImport.IResourceAccess.func_244345_a(p_244335_1_), p_244335_2_, true); // forge -- this method is only called by things that are importing datapacks (not DynamicRegistries.builtin())
    }
 
    public static <T> WorldSettingsImport<T> func_244336_a(DynamicOps<T> p_244336_0_, WorldSettingsImport.IResourceAccess p_244336_1_, DynamicRegistries.Impl p_244336_2_) {
+      return create(p_244336_0_, p_244336_1_, p_244336_2_, false); // forge -- with these patches, this method is now only called by DynamicRegistries.builtin()
+   }
+   protected final WorldSettingsImport<net.minecraft.nbt.INBT> nbtOps; // forge -- workaround for the generic ops problem when preventing redundant imports
+   public static <T> WorldSettingsImport<T> create(DynamicOps<T> p_244336_0_, net.minecraft.util.registry.WorldSettingsImport.IResourceAccess p_244336_1_, net.minecraft.util.registry.DynamicRegistries.Impl p_244336_2_, boolean importingDataPacks) {
+      if (importingDataPacks && p_244336_2_.getDatapackImports() != null) { if (!(p_244336_0_ instanceof net.minecraft.nbt.NBTDynamicOps) && !(p_244336_0_ instanceof JsonOps)) throw new IllegalArgumentException("Cannot create world import -- Unsupported ops"); return p_244336_0_ instanceof JsonOps ? (WorldSettingsImport<T>) p_244336_2_.getDatapackImports().field_244333_f : (WorldSettingsImport<T>) p_244336_2_.getDatapackImports().nbtOps;}
       WorldSettingsImport<T> worldsettingsimport = new WorldSettingsImport<>(p_244336_0_, p_244336_1_, p_244336_2_, Maps.newIdentityHashMap());
       DynamicRegistries.func_243608_a(p_244336_2_, worldsettingsimport);
+      if (importingDataPacks) { net.minecraftforge.common.ForgeHooks.onDynamicRegistriesLoaded(worldsettingsimport, p_244336_2_);}
       return worldsettingsimport;
    }
 
@@ -60,6 +_,15 @@
       this.field_240872_d_ = p_i242092_3_;
       this.field_240873_e_ = p_i242092_4_;
       this.field_244333_f = p_i242092_1_ == JsonOps.INSTANCE ? (WorldSettingsImport<JsonElement>)this : new WorldSettingsImport<>(JsonOps.INSTANCE, p_i242092_2_, p_i242092_3_, p_i242092_4_);
+      this.nbtOps = p_i242092_1_ == net.minecraft.nbt.NBTDynamicOps.field_210820_a ? (WorldSettingsImport<net.minecraft.nbt.INBT>)this : new WorldSettingsImport<>(net.minecraft.nbt.NBTDynamicOps.field_210820_a, p_i242092_2_, p_i242092_3_, p_i242092_4_, this.field_244333_f);
+   } // forge: all vanilla WSIs either are or have a jsonops delegate, we also need to have an nbtops delegate for the generic create workaround
+   private WorldSettingsImport(DynamicOps<T> p_i242092_1_, WorldSettingsImport.IResourceAccess p_i242092_2_, DynamicRegistries.Impl p_i242092_3_, IdentityHashMap<RegistryKey<? extends Registry<?>>, WorldSettingsImport.ResultMap<?>> p_i242092_4_, WorldSettingsImport<JsonElement> jsonOps) {
+      super(p_i242092_1_);
+      this.field_244332_c = p_i242092_2_;
+      this.field_240872_d_ = p_i242092_3_;
+      this.field_240873_e_ = p_i242092_4_;
+      this.field_244333_f = jsonOps;
+      this.nbtOps = (WorldSettingsImport<net.minecraft.nbt.INBT>)this;
    }
 
    protected <E> DataResult<Pair<Supplier<E>, T>> func_241802_a_(T p_241802_1_, RegistryKey<? extends Registry<E>> p_241802_2_, Codec<E> p_241802_3_, boolean p_241802_4_) {
@@ -190,6 +_,7 @@
                ) {
                   JsonParser jsonparser = new JsonParser();
                   JsonElement jsonelement = jsonparser.parse(reader);
+                  if (jsonelement!= null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_241879_3_.func_240901_a_().toString());
                   return p_241879_4_.parse(p_241879_1_, jsonelement).map((p_244347_0_) -> {
                      return Pair.of(p_244347_0_, OptionalInt.empty());
                   });
@@ -231,6 +_,7 @@
 
          public <E> DataResult<Pair<E, OptionalInt>> func_241879_a(DynamicOps<JsonElement> p_241879_1_, RegistryKey<? extends Registry<E>> p_241879_2_, RegistryKey<E> p_241879_3_, Decoder<E> p_241879_4_) {
             JsonElement jsonelement = this.field_244349_a.get(p_241879_3_);
+            if (jsonelement!= null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_241879_3_.func_240901_a_().toString());
             return jsonelement == null ? DataResult.error("Unknown element: " + p_241879_3_) : p_241879_4_.parse(p_241879_1_, jsonelement).setLifecycle(this.field_244351_c.get(p_241879_3_)).map((p_244353_2_) -> {
                return Pair.of(p_244353_2_, OptionalInt.of(this.field_244350_b.getInt(p_241879_3_)));
             });
